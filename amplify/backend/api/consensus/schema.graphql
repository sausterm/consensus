type User @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  username: String!
  userProfile: UserProfile @hasOne
  responses: [Response] @hasMany(indexName: "byRespondent", fields: ["id"])
}

type UserProfile @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  user: User @belongsTo(fields: ["userId"])
  userId: ID!
  age: Int
  sex: String
  gender: String
  height: Float
  occupation: String
  religion: String
  currentNationality: String
  countryOfBirth: String
}

type Poll @model
  @auth(rules: [{ allow: public, provider: apiKey, operations: [create, read, update, delete] }])
{
  id: ID! @primaryKey(sortKeyFields: ["createdAt"])
  title: String!
  description: String
  topic: String! @index(name: "byTopic", sortKeyFields: ["createdAt"], queryField: "pollsByTopic")
  tags: [String]
  createdAt: AWSDateTime! @index(name: "byCreatedAt", queryField: "pollsByCreatedAt")
  questions: [Question] @hasMany
}

type Question @model 
  @auth(rules: [{ allow: public, provider: apiKey, operations: [create, read, update, delete] }])
{
  id: ID!
  pollId: ID! @index(name: "byPoll", sortKeyFields: ["id"])
  pollCreatedAt: AWSDateTime!   # Add this field to match the composite key
  content: String!
  questionType: QuestionType!
  options: [String]
  required: Boolean
  poll: Poll @belongsTo(fields: ["pollId", "pollCreatedAt"]) # Include both fields
  responses: [Response] @hasMany(indexName: "byQuestion", fields: ["id"])
}

enum QuestionType {
  TEXT
  MULTIPLE_CHOICE
  CHECKBOX
  SLIDER
  YES_NO
  RANKING
}

type Response @model
  @auth(rules: [{ allow: owner }])
{
  id: ID! @primaryKey
  pollId: ID! @index(name: "byPoll", sortKeyFields: ["createdAt"])
  questionId: ID! @index(name: "byQuestion", sortKeyFields: ["createdAt"])
  respondentId: ID! @index(name: "byRespondent", sortKeyFields: ["createdAt"])
  answer: AWSJSON
  createdAt: AWSDateTime!
  respondent: User @belongsTo(fields: ["respondentId"])
  question: Question @belongsTo(fields: ["questionId"])
}
